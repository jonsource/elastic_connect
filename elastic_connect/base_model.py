import elastic_connect
import elastic_connect.data_types as data_types
import elastic_connect.data_types.base


class Model(object):
    """Base class for Models stored in elasticseach.

    Handles creation, loading and saving of the models.
    Also handles simple SQL-like joins, in fact lazy loading dependent child/parent models.

    Attributes:
        _mapping (dict): dictionary describing the model.
                         property_name: elasticsearch data type or 'ref' for reference to other model, defined by a join
                         keys starting with _ are not saved in elasticsearch
        _es: connection to elasticsearch.
    """

    __slots__ = ('id', )

    _mapping = {  # type: dict[str:elastic_connect.data_types.base.BaseDataType]
        'id': data_types.Keyword(name='id'),
    }

    _meta = {
        '_doc_type': 'model',
    }

    print(elastic_connect._namespaces)
    _es_namespace = elastic_connect._namespaces['_default']
    _es_connection = None

    def __init__(self, **kw):
        """Creates an instance of the model using **kw parameters for setting values.

        properties defined as 'date' in cls._mapping are converted to datetime
        """

        for property, type in self._mapping.items():
            self.__update(property, type.get_default_value())
        for property, type in self._mapping.items():
            self.__update(property, type.on_update(type.from_python(kw.get(property, type.get_default_value())), self))

    @classmethod
    def get_index(cls):
        """Returns the name of the index this model is stored in.

        For ES < 5 returns what is defined in the database settings.
        For ES >= 5 returns the '_doc_type' defined in cls._mapping
        """
        # print("getindex", cls._es_namespace, cls._es_namespace.__dict__)
        return cls._es_namespace.index_prefix + cls._meta['_doc_type']

    def _compute_id(self):
        """Count or return stored id for this model instance.

        Returns None for unsaved models which should receive a unique id generated by Elasticsearch.
        Should be overriden and return some computed value for models which handle their uniqe id by themselves - mainly
        to keep a model parameter unique

        """

        return self.id

    @classmethod
    def get_es_connection(cls):
        if not cls._es_connection:
            # print(cls.__name__ + " connecting to " + str(cls._es_namespace.__dict__))
            cls._es_connection = elastic_connect.DocTypeConnection(model=cls, es_namespace=cls._es_namespace,
                                                        index=cls.get_index(),
                                                        doc_type=cls._meta['_doc_type'])
            # print("connection index name " + cls._es_connection.index_name)
        # else:
            # print(cls.__name__ + " connection already established:", cls._es_connection.__dict__)
        return cls._es_connection

    @classmethod
    def from_dict(cls, **kw):
        """Create and return an unsaved model instance based on dictionary."""

        model = cls(**kw)
        return model

    @classmethod
    def from_es(cls, hit):
        """Create and return an unsaved model instance based on Elasticsearch query result."""

        # model = cls(**hit['_source'])  # it;s better to create an empty model, but is it always possible ?

        kwargs = {}
        for property, type in cls._mapping.items():
            kwargs.update({property: type.from_es(hit['_source'])})
            kwargs['id'] = hit['_id']
        model = cls(**kwargs)
        return model

    @classmethod
    def create(cls, **kw) -> 'cls':
        """Create, save and return a model instance based on dictionary.

        Property id gets set by Elasticsearch or computed depending on cls._compute_id()
        """

        model = cls.from_dict(**kw)
        model.id = model._compute_id()
        ret = cls._create(model)
        return ret

    @classmethod
    def _create(cls, model):
        """Handles the creation of the model in Elasticsearch

        Models without an id are indexed, thus receiving id from Elasticsearch.
        Models with id are created. This prevents the creation of duplicates.
        """

        if model.id:
            response = cls.get_es_connection().create(id=model.id, body=model.to_es(exclude=['id']))
        # TODO: probably needs to call cls.refresh() to properly prevent creation of duplicates
        else:
            response = cls.get_es_connection().index(body=model.serialize(exclude=['id']))
        model.id = response['_id']
        print("model.id", model.id)
        model.post_save()
        return model

    def save(self):
        """Save a model that has an id, index a model without an id into Elasticsearch"""

        if self.id:
            self.get_es_connection().update(id=self.id, body={'doc': self.serialize(exclude=['id'])})
        else:
            response = self.get_es_connection().index(body=self.serialize(exclude=['id']))
            self.id = response['_id']
            print("model.id from save", self.id)
        return self.post_save()

    def post_save(self):
        print("post_save", self.__class__.__name__, self.id)
        ret = []
        for property, type in self._mapping.items():
            ret.append(type.on_save(model=self))
        print("post_save ret", self.id, ret)
        ret = [r for r in ret if r is not None]
        if len(ret):
            # resave, because some child models were updated
            self.save()
        return self

    def delete(self):
        """Delete a model from elasticsearch."""
        self.get_es_connection().delete(id=self.id)

    def _lazy_load(self):
        """Lazy loads model's joins - child / parent models."""
        for property, type in self._mapping.items():
            print("pre lazy", property, self.__getattribute__(property))
            self.__update(property, type.lazy_load(self))
        print("_lazy_loaded:", self)
        return self

    @classmethod
    def get(cls, id):
        """Get a model by id from Elasticsearch."""
        ret = cls.get_es_connection().get(id=id)
        return ret

    @classmethod
    def all(cls):
        """Get all models from Elasticsearch."""

        return cls.get_es_connection().search()

    @classmethod
    def find_by(cls, **kw):
        """Search for models in Elasticsearch by property values.

        For example:
            model.find_by(email="test@test.cz")
        """

        ret = cls.get_es_connection().search(body={
            "query": {
                "term": kw
            }
        })
        return ret

    def serialize(self, exclude=["password"], depth=0, to_str=False):
        """Serilaizes the model for storing to Elasticsearch.

        Joins are transformed from join: model format to join_id: id format.
        Datetime attributes are converted to iso format.
        """

        print("serialize", self.__class__.__name__, depth)
        ret = {}
        for property, type in self._mapping.items():
            print("property", property, type)
            if property not in exclude:
                ret.update({property: type.serialize(self.__getattribute__(property), depth=depth, to_str=to_str)})
        #print("serialize return:", ret)
        return ret

    # def to_dict(self, exclude=["password"]):
    #     """Serilaizes the model for storing to Elasticsearch.
    #
    #     Joins are transformed from join: model format to join_id: id format.
    #     Datetime attributes are converted to iso format.
    #     """
    #
    #     ret = {}
    #     for property, type in self._mapping.items():
    #         if property not in exclude:
    #             print("property", property)
    #             ret.update({property: type.to_dict(self.__getattribute__(property))})
    #     return ret

    def __repr__(self):
        print("repr")
        # if self.id:
        #     return str(self.serialize(depth=0))
        # return object.__repr__(self)
        #return str(self.serialize())
        if self.id:
            return object.__repr__(self) + str(self)
        return object.__repr__(self)

    def __str__(self):
        return str(self.serialize(depth=0, to_str=True))

    @classmethod
    def refresh(cls):
        """Refresh the index where this model is stored to make all changes immediately visible to others."""

        cls._es_namespace.get_es().indices.refresh(index=cls.get_index())

    # def __setattr__(self, name, value):
    #     #print("setting %s.%s = %s" % (self.__class__.__name__, name, value))
    #     if name in self._mapping:
    #
    #         # print("after", repr(self))
    #         return
    #     return super().__setattr__(name, value)

    def __update(self, name, value):
        # print("__update", value)
        super().__setattr__(name, self._mapping[name].on_update(value, self))


    @classmethod
    def get_es_mapping(cls):
        """
        Returns a dict representing the elastic search mapping for this model
        :return: dict
        """

        mapping = {}
        for name, type in cls._mapping.items():
            es_type = type.get_es_type()
            if name != 'id' and es_type:
                mapping[name] = {"type": es_type}

        print("mapping", mapping)
        return mapping
